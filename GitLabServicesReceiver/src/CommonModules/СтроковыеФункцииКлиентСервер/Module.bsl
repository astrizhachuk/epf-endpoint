////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
//  
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Разбивает строку на несколько строк по разделителю. Разделитель может иметь любую длину.
//
// Параметры:
//  Строка                 - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Примеры:
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",") - возвратит массив из 5 элементов, три из которых  - пустые строки;
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина) - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок(" один   два  ", " ") - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("") - возвратит пустой массив;
//  РазложитьСтрокуВМассивПодстрок("",,Ложь) - возвратит массив с одним элементом "" (пустой строкой);
//  РазложитьСтрокуВМассивПодстрок("", " ") - возвратит массив с одним элементом "" (пустой строкой);
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Объединяет строки из массива в строку с разделителями.
//
// Параметры:
//  Массив      - Массив - массив строк которые необходимо объединить в одну строку;
//  Разделитель - Строка - любой набор символов, который будет использован в качестве разделителя.
//
// Возвращаемое значение:
//  Строка - строка с разделителями.
// 
Функция ПолучитьСтрокуИзМассиваПодстрок(Массив, Разделитель = ",") Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Каждого Элемент Из Массив Цикл
		
		Подстрока = ?(ТипЗнч(Элемент) = Тип("Строка"), Элемент, Строка(Элемент));
		
		РазделительПодстрок = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + РазделительПодстрок + Подстрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей.
//
// Возвращаемое значение:
//  Булево - истина, если символ является разделителем.
//
Функция ЭтоРазделительСлов(КодСимвола, РазделителиСлов = Неопределено) Экспорт
	
	Если РазделителиСлов <> Неопределено Тогда
		Возврат Найти(РазделителиСлов, Символ(КодСимвола)) > 0;
	КонецЕсли;
		
	Диапазоны = Новый Массив;
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 48, 57)); 		// цифры
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 65, 90)); 		// латиница большие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 97, 122)); 		// латиница маленькие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1040, 1103)); 	// кириллица
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 95, 95)); 		// символ "_"
	
	Для Каждого Диапазон Из Диапазоны Цикл
		Если КодСимвола >= Диапазон.Мин И КодСимвола <= Диапазон.Макс Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Разбивает строку на несколько строк, используя заданный набор разделителей.
// Если параметр РазделителиСлов не задан, то разделителем слов считается любой из символов, 
// не относящихся к символам латиницы, кириллицы, цифры, подчеркивания.
//
// Параметры:
//  Строка          - Строка - строка, которую необходимо разложить на слова.
//  РазделителиСлов - Строка - строка, содержащая символы-разделители.
//
//  Возвращаемое значение:
//      массив значений, элементы которого - отдельные слова
//
// Пример:
//  РазложитьСтрокуВМассивСлов("один-@#два2_!три") возвратит массив значений: "один", "два2_", "три";
//  РазложитьСтрокуВМассивСлов("один-@#два2_!три", "#@!_") возвратит массив значений: "один-", "два2", "три".
//
Функция РазложитьСтрокуВМассивСлов(Знач Строка, РазделителиСлов = Неопределено) Экспорт
	
	Слова = Новый Массив;
	
	РазмерТекста = СтрДлина(Строка);
	НачалоСлова = 1;
	Для Позиция = 1 По РазмерТекста Цикл
		КодСимвола = КодСимвола(Строка, Позиция);
		Если ЭтоРазделительСлов(КодСимвола, РазделителиСлов) Тогда
			Если Позиция <> НачалоСлова Тогда
				Слова.Добавить(Сред(Строка, НачалоСлова, Позиция - НачалоСлова));
			КонецЕсли;
			НачалоСлова = Позиция + 1;
		КонецЕсли;
	КонецЦикла;
	
	Если Позиция <> НачалоСлова Тогда
		Слова.Добавить(Сред(Строка, НачалоСлова, Позиция - НачалоСлова));
	КонецЕсли;
	
	Возврат Слова;
	
КонецФункции

// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%ИмяПараметра");
//  Параметр<n>        - Строка - подставляемый параметр.
//
// Возвращаемое значение:
//  Строка   – текстовая строка с подставленными параметрами.
//
// Пример:
//  ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк") = "Вася пошел в Зоопарк".
//
Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ИспользоватьАльтернативныйАлгоритм = 
		Найти(Параметр1, "%")
		Или Найти(Параметр2, "%")
		Или Найти(Параметр3, "%")
		Или Найти(Параметр4, "%")
		Или Найти(Параметр5, "%")
		Или Найти(Параметр6, "%")
		Или Найти(Параметр7, "%")
		Или Найти(Параметр8, "%")
		Или Найти(Параметр9, "%");
		
	Если ИспользоватьАльтернативныйАлгоритм Тогда
		СтрокаПодстановки = ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(СтрокаПодстановки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	Иначе
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%1", Параметр1);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%2", Параметр2);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%3", Параметр3);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%4", Параметр4);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%5", Параметр5);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%6", Параметр6);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%7", Параметр7);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%8", Параметр8);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%9", Параметр9);
	КонецЕсли;
	
	Возврат СтрокаПодстановки;
КонецФункции

// Подставляет параметры в строку. Число параметров в строке не ограничено.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров
// начинается с единицы.
//
// Параметры
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%1");
//  МассивПараметров   - Массив - массив строк, которые соответствуют параметрам в строке подстановки.
//
// Возвращаемое значение:
//   Строка – строка с подставленными параметрами.
//
// Пример:
//  МассивПараметров = Новый Массив;
//  МассивПараметров = МассивПараметров.Добавить("Вася");
//  МассивПараметров = МассивПараметров.Добавить("Зоопарк");
//
//  Строка = ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), МассивПараметров);
//
Функция ПодставитьПараметрыВСтрокуИзМассива(Знач СтрокаПодстановки, Знач МассивПараметров) Экспорт
	
	СтрокаРезультата = СтрокаПодстановки;
	
	Индекс = МассивПараметров.Количество();
	Пока Индекс > 0 Цикл
		Значение = МассивПараметров[Индекс-1];
		Если Не ПустаяСтрока(Значение) Тогда
			СтрокаРезультата = СтрЗаменить(СтрокаРезультата, "%" + Формат(Индекс, "ЧГ="), Значение);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Возврат СтрокаРезультата;
	
КонецФункции

// Заменяет в шаблоне строки имена параметров на их значения. Параметры в строке выделяются с двух сторон квадратными скобками.
//
// Параметры:
//
//  ШаблонСтроки        - Строка    - строка, в которую необходимо вставить значения.
//  ВставляемыеЗначения - Структура - структура значений, где ключ - имя параметра без спецсимволов,
//                                    значение - вставляемое значение.
//
// Возвращаемое значение:
//  Строка - строка со вставленными значениями.
//
// Пример использования:
//  ВставитьПараметрыВСтроку("Здравствуй, [Имя] [Фамилия].", Новый Структура("Фамилия,Имя", "Пупкин", "Вася"));
//  Возвращает: "Здравствуй, Вася Пупкин".
Функция ВставитьПараметрыВСтроку(Знач ШаблонСтроки, ВставляемыеЗначения) Экспорт
	Результат = ШаблонСтроки;
	Для Каждого Параметр Из ВставляемыеЗначения Цикл
		Результат = СтрЗаменить(Результат, "[" + Параметр.Ключ + "]", Параметр.Значение);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Получает значения параметров из строки.
//
// Параметры:
//  СтрокаПараметров - Строка - строка, содержащая параметры, каждый из которых представляет собой
//                              фрагмент вида <Имя параметра>=<Значение>, где:
//                                Имя параметра - имя параметра; 
//                                Значение - его значение. 
//                              Фрагменты отделяются друг от друга символами ';'.
//                              Если значение содержит пробельные символы, то оно должно быть заключено в двойные
//                              кавычки (").
//                              Например:
//                               "File=""c:\InfoBases\Trade""; Usr=""Director"";"
//  Разделитель - Строка - символ, которым фрагменты отделяются друг от друга.
//
// Возвращаемое значение:
//  Структура - значения параметров, где ключ - имя параметра, значение - значение параметра.
//
// Пример:
//  Результат = СтроковыеФункцииКлиентСервер.ПараметрыИзСтроки("File=""c:\InfoBases\Trade""; Usr=""Director"";""", ";");
//  - вернет структуру:
//     ключ "File" и значение "c:\InfoBases\Trade"
//     ключ "Usr"  и значение "Director".
//
Функция ПараметрыИзСтроки(Знач СтрокаПараметров, Знач Разделитель = ";") Экспорт
	Результат = Новый Структура;
	
	ОписаниеПараметра = "";
	НайденоНачалоСтроки = Ложь;
	НомерПоследнегоСимвола = СтрДлина(СтрокаПараметров);
	Для НомерСимвола = 1 По НомерПоследнегоСимвола Цикл
		Символ =Сред(СтрокаПараметров, НомерСимвола, 1);
		Если Символ = """" Тогда
			НайденоНачалоСтроки = Не НайденоНачалоСтроки;
		КонецЕсли;
		Если Символ <> Разделитель Или НайденоНачалоСтроки Тогда
			ОписаниеПараметра = ОписаниеПараметра + Символ;
		КонецЕсли;
		Если Символ = Разделитель И Не НайденоНачалоСтроки Или НомерСимвола = НомерПоследнегоСимвола Тогда
			Позиция = Найти(ОписаниеПараметра, "=");
			Если Позиция > 0 Тогда
				ИмяПараметра = СокрЛП(Лев(ОписаниеПараметра, Позиция - 1));
				ЗначениеПараметра = СокрЛП(Сред(ОписаниеПараметра, Позиция + 1));
				ЗначениеПараметра = СократитьДвойныеКавычки(ЗначениеПараметра);
				Результат.Вставить(ИмяПараметра, ЗначениеПараметра);
			КонецЕсли;
			ОписаниеПараметра = "";
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

//Устарела. Получает значения параметров из строки.
//
// Параметры:
//  СтрокаПараметров - Строка - строка, содержащая параметры, каждый из которых представляет собой
//                              фрагмент вида <Имя параметра>=<Значение>, где:
//                                Имя параметра — имя параметра; 
//                                Значение — его значение. 
//                              Фрагменты отделяются друг от друга символами ';'.
//                              Если значение содержит пробельные символы, то оно должно быть заключено в двойные кавычки (").
//                              Например:
//                               "File=""c:\InfoBases\Trade""; Usr=""Director"";"
//
// Возвращаемое значение:
//  Структура - структура параметров, где ключ - имя параметра, значение - значение параметра.
//
Функция ПолучитьПараметрыИзСтроки(Знач СтрокаПараметров) Экспорт
	
	Результат = Новый Структура;
	
	СимволДвойныеКавычки = Символ(34); // (")
	
	МассивПодстрок = РазложитьСтрокуВМассивПодстрок(СтрокаПараметров, ";");
	
	Для Каждого СтрокаПараметра Из МассивПодстрок Цикл
		
		ПозицияПервогоЗнакаРавенства = Найти(СтрокаПараметра, "=");
		
		// Получаем имя параметра
		ИмяПараметра = СокрЛП(Лев(СтрокаПараметра, ПозицияПервогоЗнакаРавенства - 1));
		
		// Получаем значение параметра
		ЗначениеПараметра = СокрЛП(Сред(СтрокаПараметра, ПозицияПервогоЗнакаРавенства + 1));
		
		Если  Лев(ЗначениеПараметра, 1) = СимволДвойныеКавычки
			И Прав(ЗначениеПараметра, 1) = СимволДвойныеКавычки Тогда
			
			ЗначениеПараметра = Сред(ЗначениеПараметра, 2, СтрДлина(ЗначениеПараметра) - 2);
			
		КонецЕсли;
		
		Если Не ПустаяСтрока(ИмяПараметра) Тогда
			
			Результат.Вставить(ИмяПараметра, ЗначениеПараметра);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции
	
// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  СтрокаПроверки          - Строка - строка для проверки.
//  УчитыватьЛидирующиеНули - Булево - нужно ли учитывать лидирующие нули.
//  УчитыватьПробелы        - Булево - нужно ли учитывать пробелы.
//
// Возвращаемое значение:
//  Истина       - строка содержит только цифры или пустая;
//  Ложь         - строка содержит не только цифры.
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, Знач УчитыватьЛидирующиеНули = Истина, Знач УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Проверяет, содержит ли строка только символы кириллического алфавита.
//
// Параметры:
//  УчитыватьРазделителиСлов - Булево - учитывать ли разделители слов или они являются исключением.
//  ДопустимыеСимволы - строка для проверки.
//
// Возвращаемое значение:
//  Истина       - строка содержит только кириллические (или допустимые) символы или пустая;
//  Ложь         - строка содержит не только кириллические (или допустимые) символы.
//
Функция ТолькоКириллицаВСтроке(Знач СтрокаПроверки, Знач УчитыватьРазделителиСлов = Истина, ДопустимыеСимволы = "") Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	КодыДопустимыхСимволов = Новый Массив;
	КодыДопустимыхСимволов.Добавить(1105); // "ё"
	КодыДопустимыхСимволов.Добавить(1025); // "Ё"
	
	Для а = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		КодыДопустимыхСимволов.Добавить(КодСимвола(Сред(ДопустимыеСимволы, а, 1)));
	КонецЦикла;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если ((КодСимвола < 1040) Или (КодСимвола > 1103)) 
			И (КодыДопустимыхСимволов.Найти(КодСимвола) = Неопределено) 
			И Не (Не УчитыватьРазделителиСлов И ЭтоРазделительСлов(КодСимвола)) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Проверяет, содержит ли строка только символы латинского алфавита.
//
// Параметры:
//  УчитыватьРазделителиСлов - Булево - учитывать ли разделители слов или они являются исключением.
//  ДопустимыеСимволы - строка для проверки.
//
// Возвращаемое значение:
//  Истина       - строка содержит только латинские (или допустимые) символы;
//  Ложь         - строка содержит не только латинские (или допустимые) символы.
//
Функция ТолькоЛатиницаВСтроке(Знач СтрокаПроверки, Знач УчитыватьРазделителиСлов = Истина, ДопустимыеСимволы = "") Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	КодыДопустимыхСимволов = Новый Массив;
	
	Для а = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		КодыДопустимыхСимволов.Добавить(КодСимвола(Сред(ДопустимыеСимволы, а, 1)));
	КонецЦикла;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если ((КодСимвола < 65) Или (КодСимвола > 90 И КодСимвола < 97) Или (КодСимвола > 122))
			И (КодыДопустимыхСимволов.Найти(КодСимвола) = Неопределено) 
			И Не (Не УчитыватьРазделителиСлов И ЭтоРазделительСлов(КодСимвола)) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Удаляет двойные кавычки с начала и конца строки, если они есть.
//
// Параметры:
//  Строка - входная строка;
//
// Возвращаемое значение:
//  Строка - строка без двойных кавычек.
// 
Функция СократитьДвойныеКавычки(Знач Строка) Экспорт
	
	Пока Лев(Строка, 1) = """" Цикл
		Строка = Сред(Строка, 2); 
	КонецЦикла; 
	
	Пока Прав(Строка, 1) = """" Цикл
		Строка = Лев(Строка, СтрДлина(Строка) - 1);
	КонецЦикла;
	
	Возврат Строка;
	
КонецФункции 

// Удаляет из строки указанное количество символов справа.
//
// Параметры:
//  Текст         - Строка - строка, в которой необходимо удалить последние символы;
//  ЧислоСимволов - Число  - количество удаляемых символов.
//
Процедура УдалитьПоследнийСимволВСтроке(Текст, ЧислоСимволов) Экспорт
	
	Текст = Лев(Текст, СтрДлина(Текст) - ЧислоСимволов);
	
КонецПроцедуры 

// Осуществляет поиск символа, начиная с конца строки.
//
// Параметры:
//  Строка - Строка - строка, в которой осуществляется поиск;
//  Символ - Строка - искомый символ.
//
// Возвращаемое значение:
//  Число - позиция символа в строке. 
//          Если строка не содержит указанного символа, то возвращается 0.
//
Функция НайтиСимволСКонца(Знач Строка, Знач Символ) Экспорт
	
	Для Позиция = -СтрДлина(Строка) По -1 Цикл
		Если Сред(Строка, -Позиция, 1) = Символ Тогда
			Возврат -Позиция;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
		
КонецФункции

// Проверяет, является ли строка уникальным идентификатором.
// В качестве уникального идентификатора предполагается строка вида
// "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX", где X = [0..9,a..f].
//
// Параметры:
//  ИдентификаторСтрока - Строка - проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если переданная строка является уникальным идентификатором.
Функция ЭтоУникальныйИдентификатор(Знач Строка) Экспорт
	
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Если КодСимвола(Шаблон, Позиция) = 88 И ((КодСимвола(Строка, Позиция) < 48 Или КодСимвола(Строка, Позиция) > 57) И (КодСимвола(Строка, Позиция) < 97 Или КодСимвола(Строка, Позиция) > 102))
			Или КодСимвола(Шаблон, Позиция) = 45 И КодСимвола(Строка, Позиция) <> 45 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

// Формирует строку повторяющихся символов заданной длины.
//
// Параметры:
//  Символ      - Строка - символ, из которого будет формироваться строка.
//  ДлинаСтроки - Число  - требуемая длина результирующей строки.
//
// Возвращаемое значение:
//  Строка - строка, состоящая из повторяющихся символов.
//
Функция СформироватьСтрокуСимволов(Знач Символ, Знач ДлинаСтроки) Экспорт
	
	Результат = "";
	Для Счетчик = 1 По ДлинаСтроки Цикл
		Результат = Результат + Символ;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Дополняет строку символами слева или справа до заданной длины и возвращает ее.
// Незначащие символы слева и справа удаляются. По умолчанию функция дополняет строку символами "0" (ноль) слева.
//
// Параметры:
//  Строка      - Строка - исходная строка, которую необходимо дополнить символами;
//  ДлинаСтроки - Число  - требуемая результирующая длина строки;
//  Символ      - Строка - символ, которым необходимо дополнить строку;
//  Режим       - Строка - "Слева" или "Справа" - режим добавления символов к исходной строке.
// 
// Возвращаемое значение:
//  Строка - строка, дополненная символами.
//
// Пример 1:
// Строка = "1234"; ДлинаСтроки = 10; Символ = "0"; Режим = "Слева"
// Возврат: "0000001234"
//
// Пример 2:
// Строка = " 1234  "; ДлинаСтроки = 10; Символ = "#"; Режим = "Справа"
// Возврат: "1234######"
//
Функция ДополнитьСтроку(Знач Строка, Знач ДлинаСтроки, Знач Символ = "0", Знач Режим = "Слева") Экспорт
	
	// длина символа не должна превышать единицы
	Символ = Лев(Символ, 1);
	
	// удаляем крайние пробелы слева и справа строки
	Строка = СокрЛП(Строка);
	
	КоличествоСимволовНадоДобавить = ДлинаСтроки - СтрДлина(Строка);
	
	Если КоличествоСимволовНадоДобавить > 0 Тогда
		
		СтрокаДляДобавления = СформироватьСтрокуСимволов(Символ, КоличествоСимволовНадоДобавить);
		
		Если ВРег(Режим) = "СЛЕВА" Тогда
			
			Строка = СтрокаДляДобавления + Строка;
			
		ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
			
			Строка = Строка + СтрокаДляДобавления;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

// Удаляет крайние повторяющиеся символы слева или справа в строке.
//
// Параметры:
//  Строка      - Строка - исходная строка, из которой необходимо удалить крайние повторяющиеся символы;
//  Символ      - Строка - искомый символ для удаления;
//  Режим       - Строка - "Слева" или "Справа" - режим удаления символов в исходной строке.
//
// Возвращаемое значение:
//  Строка - обрезанная строка.
//
Функция УдалитьПовторяющиесяСимволы(Знач Строка, Знач Символ, Знач Режим = "Слева") Экспорт
	
	Если ВРег(Режим) = "СЛЕВА" Тогда
		
		Пока Лев(Строка, 1)= Символ Цикл
			
			Строка = Сред(Строка, 2);
			
		КонецЦикла;
		
	ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
		
		Пока Прав(Строка, 1)= Символ Цикл
			
			Строка = Лев(Строка, СтрДлина(Строка) - 1);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Строка;
КонецФункции

// Выполняет замену символов в строке.
//
// Параметры:
//  ЗаменяемыеСимволы - Строка - строка символов, каждый из которых требует замены;
//  Строка            - Строка - исходная строка, в которой требуется замена символов;
//  СимволыЗамены     - Строка - строка символов, на каждый из которых нужно заменить символы параметра ЗаменяемыеСимволы.
// 
//  Возвращаемое значение:
//   Строка - строка после замены символов.
//
//  Примечание: функция предназначена для простых случаев, например, для замены латиницы на похожие кириллические символы.
//              Функция не анализирует повторную замену символов, поэтому такой вызов:
//               ЗаменитьОдниСимволыДругими("кр", "карета", "гз") вернет слово "газета", а
//               ЗаменитьОдниСимволыДругими("кр", "карета", "рк") не вернет слово "ракета".
//
Функция ЗаменитьОдниСимволыДругими(ЗаменяемыеСимволы, Строка, СимволыЗамены) Экспорт
	
	Результат = Строка;
	
	Для НомерСимвола = 1 По СтрДлина(ЗаменяемыеСимволы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, НомерСимвола, 1), Сред(СимволыЗамены, НомерСимвола, 1));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Выполняет преобразование арабского числа в римское.
//
// Параметры:
//	АрабскоеЧисло		  - число, целое, от 0 до 999;
//	ИспользоватьКириллицу - булево, использовать в качестве арабских цифр кириллицу или латиницу.
//
// Возвращаемое значение:
//	Строка - число в римской нотации.
//
// Пример:
//	ПреобразоватьЧислоВРимскуюНотацию(17) = "ХVII".
//
Функция ПреобразоватьЧислоВРимскуюНотацию(АрабскоеЧисло, ИспользоватьКириллицу = Истина) Экспорт
	
	РимскоеЧисло	= "";
	АрабскоеЧисло	= ДополнитьСтроку(АрабскоеЧисло, 3);
	
	Если ИспользоватьКириллицу Тогда
		c1 = "1"; c5 = "У"; c10 = "Х"; c50 = "Л"; c100 ="С"; c500 = "Д"; c1000 = "М";
		
	Иначе
		c1 = "I"; c5 = "V"; c10 = "X"; c50 = "L"; c100 ="C"; c500 = "D"; c1000 = "M";
		
	КонецЕсли;
	
	Единицы	= Число(Сред(АрабскоеЧисло, 3, 1));
	Десятки	= Число(Сред(АрабскоеЧисло, 2, 1));
	Сотни	= Число(Сред(АрабскоеЧисло, 1, 1));
	
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(Сотни,   c100, c500, c1000);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(Десятки, c10,  c50,  c100);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(Единицы, c1,   c5,   c10);
	
	Возврат РимскоеЧисло;
	
КонецФункции 

// Выполняет преобразование римского числа в арабское
//
// Параметры:
//	РимскоеЧисло		  - Строка - число, записанное римскими цифрами;
//	ИспользоватьКириллицу - Булево - использовать в качестве арабских цифр кириллицу или латиницу.
//
// Возвращаемое значение:
//	Число.
//
// Пример:
//	ПреобразоватьЧислоВАрабскуюНотацию("ХVII") = 17.
//
Функция ПреобразоватьЧислоВАрабскуюНотацию(РимскоеЧисло, ИспользоватьКириллицу = Истина) Экспорт
	
	АрабскоеЧисло=0;
	
	Если ИспользоватьКириллицу Тогда
		c1 = "1"; c5 = "У"; c10 = "Х"; c50 = "Л"; c100 ="С"; c500 = "Д"; c1000 = "М";
		
	Иначе
		c1 = "I"; c5 = "V"; c10 = "X"; c50 = "L"; c100 ="C"; c500 = "D"; c1000 = "M";
		
	КонецЕсли;
	
	РимскоеЧисло = СокрЛП(РимскоеЧисло);
	ЧислоСимволов = СтрДлина(РимскоеЧисло);
	
	Для Сч=1 По ЧислоСимволов Цикл
		Если Сред(РимскоеЧисло,Сч,1) = c1000 Тогда
			АрабскоеЧисло = АрабскоеЧисло+1000;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c500 Тогда
			АрабскоеЧисло = АрабскоеЧисло+500;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c100 Тогда
			Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c500) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c1000)) Тогда
				АрабскоеЧисло = АрабскоеЧисло-100;
			Иначе
				АрабскоеЧисло = АрабскоеЧисло+100;
			КонецЕсли;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c50 Тогда
			АрабскоеЧисло = АрабскоеЧисло+50;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c10 Тогда
			Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c50) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c100)) Тогда
				АрабскоеЧисло = АрабскоеЧисло-10;
			Иначе
				АрабскоеЧисло = АрабскоеЧисло+10;
			КонецЕсли;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c5 Тогда
			АрабскоеЧисло = АрабскоеЧисло+5;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c1 Тогда
			Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c5) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c10)) Тогда
				АрабскоеЧисло = АрабскоеЧисло-1;
			Иначе
				АрабскоеЧисло = АрабскоеЧисло+1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат АрабскоеЧисло;
	
КонецФункции 

// Возвращает текстовое представление числа с единицей измерения в правильном склонении и числе.
//
// Параметры:
//  Число                       - Число  - любое целое число.
//	ПараметрыПредметаИсчисления - Строка - варианты написания единицы измерения в родительном падеже для одной,
//										   для двух и для пяти единиц, разделитель - запятая.
//
// Возвращаемое значение:
//  Строка - текстовое представление количества единиц, число записывается цифрами.
//
// Примеры:
//  ЧислоЦифрамиПредметИсчисленияПрописью(23,  "минуту,минуты,минут") = "23 минуты";
// 	ЧислоЦифрамиПредметИсчисленияПрописью(15,  "минуту,минуты,минут") = "15 минут".
Функция ЧислоЦифрамиПредметИсчисленияПрописью(Знач Число, Знач ПараметрыПредметаИсчисления) Экспорт

	Результат = Формат(Число,"ЧН=0");
	
	МассивПредставлений = Новый Массив;
	
	Позиция = Найти(ПараметрыПредметаИсчисления, ",");
	Пока Позиция > 0 Цикл
		Значение = СокрЛП(Лев(ПараметрыПредметаИсчисления, Позиция-1));
		ПараметрыПредметаИсчисления = Сред(ПараметрыПредметаИсчисления, Позиция + 1);
		МассивПредставлений.Добавить(Значение);
		Позиция = Найти(ПараметрыПредметаИсчисления, ",");
	КонецЦикла;
	
	Если СтрДлина(ПараметрыПредметаИсчисления) > 0 Тогда
		Значение = СокрЛП(ПараметрыПредметаИсчисления);
		МассивПредставлений.Добавить(Значение);
	КонецЕсли;	
	
	Если Число >= 100 Тогда
		Число = Число - Цел(Число / 100)*100;
	КонецЕсли;
	
	Если Число > 20 Тогда
		Число = Число - Цел(Число/10)*10;
	КонецЕсли;
	
	Если Число = 1 Тогда
		Результат = Результат + " " + МассивПредставлений[0];
	ИначеЕсли Число > 1 И Число < 5 Тогда
		Результат = Результат + " " + МассивПредставлений[1];
	Иначе
		Результат = Результат + " " + МассивПредставлений[2];
	КонецЕсли;
	
	Возврат Результат;	
			
КонецФункции

// Очищает текст в формате HTML от тегов и возвращает неформатированный текст. 
//
// Параметры:
//  ИсходныйТекст - Строка - текст в формате HTML.
//
// Возвращаемое значение:
//  Строка - текст, очищенный от тегов, скриптов и заголовков.
//
Функция ИзвлечьТекстИзHTML(Знач ИсходныйТекст) Экспорт
	Результат = "";
	
	Текст = НРег(ИсходныйТекст);
	
	// отрезаем все что не body
	Позиция = Найти(Текст, "<body");
	Если Позиция > 0 Тогда
		Текст = Сред(Текст, Позиция + 5);
		ИсходныйТекст = Сред(ИсходныйТекст, Позиция + 5);
		Позиция = Найти(Текст, ">");
		Если Позиция > 0 Тогда
			Текст = Сред(Текст, Позиция + 1);
			ИсходныйТекст = Сред(ИсходныйТекст, Позиция + 1);
		КонецЕсли;
	КонецЕсли;
	
	Позиция = Найти(Текст, "</body>");
	Если Позиция > 0 Тогда
		Текст = Лев(Текст, Позиция - 1);
		ИсходныйТекст = Лев(ИсходныйТекст, Позиция - 1);
	КонецЕсли;
	
	// вырезаем скрипты
	Позиция = Найти(Текст, "<script");
	Пока Позиция > 0 Цикл
		ПозицияЗакрывающегоТега = Найти(Текст, "</script>");
		Если ПозицияЗакрывающегоТега = 0 Тогда
			// не найден закрывающий тег - вырезаем оставшийся текст.
			ПозицияЗакрывающегоТега = СтрДлина(Текст);
		КонецЕсли;
		Текст = Лев(Текст, Позиция - 1) + Сред(Текст, ПозицияЗакрывающегоТега + 9);
		ИсходныйТекст = Лев(ИсходныйТекст, Позиция - 1) + Сред(ИсходныйТекст, ПозицияЗакрывающегоТега + 9);
		Позиция = Найти(Текст, "<script");
	КонецЦикла;
	
	// вырезаем стили
	Позиция = Найти(Текст, "<style");
	Пока Позиция > 0 Цикл
		ПозицияЗакрывающегоТега = Найти(Текст, "</style>");
		Если ПозицияЗакрывающегоТега = 0 Тогда
			// не найден закрывающий тег - вырезаем оставшийся текст.
			ПозицияЗакрывающегоТега = СтрДлина(Текст);
		КонецЕсли;
		Текст = Лев(Текст, Позиция - 1) + Сред(Текст, ПозицияЗакрывающегоТега + 8);
		ИсходныйТекст = Лев(ИсходныйТекст, Позиция - 1) + Сред(ИсходныйТекст, ПозицияЗакрывающегоТега + 8);
		Позиция = Найти(Текст, "<style");
	КонецЦикла;
	
	// вырезаем все теги	
	Позиция = Найти(Текст, "<");
	Пока Позиция > 0 Цикл
		Результат = Результат + Лев(ИсходныйТекст, Позиция-1);
		Текст = Сред(Текст, Позиция + 1);
		ИсходныйТекст = Сред(ИсходныйТекст, Позиция + 1);
		Позиция = Найти(Текст, ">");
		Если Позиция > 0 Тогда
			Текст = Сред(Текст, Позиция + 1);
			ИсходныйТекст = Сред(ИсходныйТекст, Позиция + 1);
		КонецЕсли;
		Позиция = Найти(Текст, "<");
	КонецЦикла;
	Результат = Результат + ИсходныйТекст;
	
	Возврат СокрЛП(Результат);
КонецФункции

// Возвращает хеш по алгоритму MD5 для произвольной строки.
//
// Параметры:
//  Строка - Строка - произвольная строка любой длины
//
// Возвращаемое значение:
//  Строка - хеш, вычисленный из строки
Функция ВычислитьХешСтрокиПоАлгоритмуMD5(Знач Строка) Экспорт
	
	a = ЧислоВБинарныйМассив(1732584193); // 01 23 45 67; (шестнадцатеричное представление, сначала младший байт)
	b = ЧислоВБинарныйМассив(4023233417); // 89 AB CD EF;
	c = ЧислоВБинарныйМассив(2562383102); // FE DC BA 98;
	d = ЧислоВБинарныйМассив(271733878);  // 76 54 32 10;
	
	X = Новый Массив(16); // X - блок данных размером 512 бит, массив из 32-битных слов
	
	// разбиваем строку на блоки по 512 бит
	МассивБлоковИзСтроки = ПолучитьМассивБлоковБайтовИзСтроки(Строка);
	
	// для каждого блока производим расчет
	Для НомерБлока = 0 По МассивБлоковИзСтроки.Количество() - 1 Цикл 
		Блок = МассивБлоковИзСтроки[НомерБлока];
		Для НомерСлова = 0 По 15 Цикл
			Слово = 0;
			Для НомерБайта = 1 По 4 Цикл
				Слово = Слово + Блок[НомерСлова * 4 + НомерБайта - 1] * Pow(256, НомерБайта - 1);
			КонецЦикла;
			X[НомерСлова] = Слово; 
		КонецЦикла;
		
		// в последний блок дописываем длину строки в битах
		Если НомерБлока = МассивБлоковИзСтроки.Количество() - 1 Тогда
			РазмерСтрокиВБитах = СтрДлина(Строка) * 8;
			X[14] = РазмерСтрокиВБитах % Pow(2,32); // сначала младшие 4 байта
			X[15] = Цел(РазмерСтрокиВБитах / Pow(2,32)) % Pow(2,64); // если длина превосходит (2^64 - 1) бит, то старшие биты откидываем
		КонецЕсли;
		РассчитатьБлок(a, b, c, d, X);
	КонецЦикла;
	
	Результат = ЧислоВШестнадцатеричномПредставлении(БинарныйМассивВЧисло(a))
			  + ЧислоВШестнадцатеричномПредставлении(БинарныйМассивВЧисло(b))
			  + ЧислоВШестнадцатеричномПредставлении(БинарныйМассивВЧисло(c))
			  + ЧислоВШестнадцатеричномПредставлении(БинарныйМассивВЧисло(d));
	
	Возврат Результат;
	
КонецФункции

// Объединяет строки из массива в строку с разделителями.
//
// Параметры:
//  Массив      - Массив - массив строк которые необходимо объединить в одну строку;
//  Разделитель - Строка - любой набор символов, который будет использован в качестве разделителя.
//  СокращатьНепечатаемыеСимволы - Булево - обрезать непечатаемые символы по краям подстрок перед объединением
//                                          в строку с разделителями.
//
// Возвращаемое значение:
//  Строка - строка с разделителями.
// 
Функция СтрокаИзМассиваПодстрок(Массив, Разделитель = ",", СокращатьНепечатаемыеСимволы = Ложь) Экспорт
	
	Результат = "";
	
	Для Индекс = 0 По Массив.ВГраница() Цикл
		Подстрока = Массив[Индекс];
		
		Если СокращатьНепечатаемыеСимволы Тогда
			Подстрока = СокрЛП(Подстрока);
		КонецЕсли;
		
		Если ТипЗнч(Подстрока) <> Тип("Строка") Тогда
			Подстрока = Строка(Подстрока);
		КонецЕсли;
		
		Если Индекс > 0 Тогда
			Результат = Результат + Разделитель;
		КонецЕсли;
		
		Результат = Результат + Подстрока;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Выполняет преобразование цифры в римскую нотацию. 
//
// Параметры
//	Цифра - Число - цифра от 0 до 9.
//  РимскаяЕдиница, РимскаяПятерка, РимскаяДесятка - Строка - символы, соответствующие римским цифрам.
//
// Возвращаемое значение
//	Строка - цифра в римской нотации.
//
// Пример: 
//	ПреобразоватьЦифруВРимскуюНотацию(7,"I","V","X") = "VII".
//
Функция ПреобразоватьЦифруВРимскуюНотацию(Цифра, РимскаяЕдиница, РимскаяПятерка, РимскаяДесятка)
	
	РимскаяЦифра="";
	Если Цифра = 1 Тогда
		РимскаяЦифра = РимскаяЕдиница
	ИначеЕсли Цифра = 2 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 3 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 4 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяПятерка;
	ИначеЕсли Цифра = 5 Тогда
		РимскаяЦифра = РимскаяПятерка;
	ИначеЕсли Цифра = 6 Тогда
		РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница;
	ИначеЕсли Цифра = 7 Тогда
		РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 8 Тогда
		РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 9 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяДесятка;
	КонецЕсли;
	Возврат РимскаяЦифра;
	
КонецФункции

// Вставляет параметры в строку, учитывая, что в параметрах могут использоваться подстановочные слова %1, %2 и т.д.
Функция ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = Найти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = "";
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр =  Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр =  Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр =  Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр =  Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр =  Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр =  Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр =  Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр =  Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр =  Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = "" Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = Найти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции


// ВычислитьХешСтрокиПоАлгоритмуMD5

Функция ПолучитьМассивБлоковБайтовИзСтроки(Знач Строка)
	Результат = Новый Массив;
	Строка = Строка + Символ(128); // единичный бит + выравнивание нолями до байта
	Пока СтрДлина(Строка) > 0 Цикл
		БлокБайтов = ПолучитьБлокБайтовИзСтроки(Лев(Строка, 64));
		Результат.Добавить(БлокБайтов);
		
		// если последние 8 байт получились не нулевые, то добавляем еще один нулевой блок
		Если СтрДлина(Строка) > 56 И СтрДлина(Строка) < 64 Тогда
			Результат.Добавить(ПолучитьБлокБайтовИзСтроки(""));
		КонецЕсли;
		
		Строка = Сред(Строка, 65);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ПолучитьБлокБайтовИзСтроки(Знач Строка)
	Результат = Новый Массив;
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Результат.Добавить(КодСимвола(Сред(Строка, Позиция, 1)));
	КонецЦикла;
	
	// дополняем блок нолями
	Для Индекс = Позиция По 64 Цикл
		Результат.Добавить(0);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Процедура РассчитатьБлок(a, b, c, d, X)
	aa = СкопироватьМассив(a);
	bb = СкопироватьМассив(b);
	cc = СкопироватьМассив(c);
	dd = СкопироватьМассив(d);
	
	// раунд 1
	ВыполнитьОперациюСФункциейF(a,b,c,d, X[ 0],  7, 3614090360); // 0xd76aa478 /* 1 */
	ВыполнитьОперациюСФункциейF(d,a,b,c, X[ 1], 12, 3905402710); // 0xe8c7b756 /* 2 */
	ВыполнитьОперациюСФункциейF(c,d,a,b, X[ 2], 17,  606105819); // 0x242070db /* 3 */
	ВыполнитьОперациюСФункциейF(b,c,d,a, X[ 3], 22, 3250441966); // 0xc1bdceee /* 4 */
	ВыполнитьОперациюСФункциейF(a,b,c,d, X[ 4],  7, 4118548399); // 0xf57c0faf /* 5 */
	ВыполнитьОперациюСФункциейF(d,a,b,c, X[ 5], 12, 1200080426); // 0x4787c62a /* 6 */
	ВыполнитьОперациюСФункциейF(c,d,a,b, X[ 6], 17, 2821735955); // 0xa8304613 /* 7 */
	ВыполнитьОперациюСФункциейF(b,c,d,a, X[ 7], 22, 4249261313); // 0xfd469501 /* 8 */
	ВыполнитьОперациюСФункциейF(a,b,c,d, X[ 8],  7, 1770035416); // 0x698098d8 /* 9 */
	ВыполнитьОперациюСФункциейF(d,a,b,c, X[ 9], 12, 2336552879); // 0x8b44f7af /* 10 */
	ВыполнитьОперациюСФункциейF(c,d,a,b, X[10], 17, 4294925233); // 0xffff5bb1 /* 11 */
	ВыполнитьОперациюСФункциейF(b,c,d,a, X[11], 22, 2304563134); // 0x895cd7be /* 12 */
	ВыполнитьОперациюСФункциейF(a,b,c,d, X[12],  7, 1804603682); // 0x6b901122 /* 13 */
	ВыполнитьОперациюСФункциейF(d,a,b,c, X[13], 12, 4254626195); // 0xfd987193 /* 14 */
	ВыполнитьОперациюСФункциейF(c,d,a,b, X[14], 17, 2792965006); // 0xa679438e /* 15 */
	ВыполнитьОперациюСФункциейF(b,c,d,a, X[15], 22, 1236535329); // 0x49b40821 /* 16 */
	
	// раунд 2
	ВыполнитьОперациюСФункциейG(a,b,c,d, X[ 1],  5, 4129170786); // 0xf61e2562 /* 17 */
	ВыполнитьОперациюСФункциейG(d,a,b,c, X[ 6],  9, 3225465664); // 0xc040b340 /* 18 */
	ВыполнитьОперациюСФункциейG(c,d,a,b, X[11], 14,  643717713); // 0x265e5a51 /* 19 */
	ВыполнитьОперациюСФункциейG(b,c,d,a, X[ 0], 20, 3921069994); // 0xe9b6c7aa /* 20 */
	ВыполнитьОперациюСФункциейG(a,b,c,d, X[ 5],  5, 3593408605); // 0xd62f105d /* 21 */
	ВыполнитьОперациюСФункциейG(d,a,b,c, X[10],  9,   38016083); //  0x2441453 /* 22 */
	ВыполнитьОперациюСФункциейG(c,d,a,b, X[15], 14, 3634488961); // 0xd8a1e681 /* 23 */
	ВыполнитьОперациюСФункциейG(b,c,d,a, X[ 4], 20, 3889429448); // 0xe7d3fbc8 /* 24 */
	ВыполнитьОперациюСФункциейG(a,b,c,d, X[ 9],  5,  568446438); // 0x21e1cde6 /* 25 */
	ВыполнитьОперациюСФункциейG(d,a,b,c, X[14],  9, 3275163606); // 0xc33707d6 /* 26 */
	ВыполнитьОперациюСФункциейG(c,d,a,b, X[ 3], 14, 4107603335); // 0xf4d50d87 /* 27 */
	ВыполнитьОперациюСФункциейG(b,c,d,a, X[ 8], 20, 1163531501); // 0x455a14ed /* 28 */
	ВыполнитьОперациюСФункциейG(a,b,c,d, X[13],  5, 2850285829); // 0xa9e3e905 /* 29 */
	ВыполнитьОперациюСФункциейG(d,a,b,c, X[ 2],  9, 4243563512); // 0xfcefa3f8 /* 30 */
	ВыполнитьОперациюСФункциейG(c,d,a,b, X[ 7], 14, 1735328473); // 0x676f02d9 /* 31 */
	ВыполнитьОперациюСФункциейG(b,c,d,a, X[12], 20, 2368359562); // 0x8d2a4c8a /* 32 */
	
	// раунд 3
	ВыполнитьОперациюСФункциейH(a,b,c,d, X[ 5],  4, 4294588738); // 0xfffa3942 /* 33 */
	ВыполнитьОперациюСФункциейH(d,a,b,c, X[ 8], 11, 2272392833); // 0x8771f681 /* 34 */
	ВыполнитьОперациюСФункциейH(c,d,a,b, X[11], 16, 1839030562); // 0x6d9d6122 /* 35 */
	ВыполнитьОперациюСФункциейH(b,c,d,a, X[14], 23, 4259657740); // 0xfde5380c /* 36 */
	ВыполнитьОперациюСФункциейH(a,b,c,d, X[ 1],  4, 2763975236); // 0xa4beea44 /* 37 */
	ВыполнитьОперациюСФункциейH(d,a,b,c, X[ 4], 11, 1272893353); // 0x4bdecfa9 /* 38 */
	ВыполнитьОперациюСФункциейH(c,d,a,b, X[ 7], 16, 4139469664); // 0xf6bb4b60 /* 39 */
	ВыполнитьОперациюСФункциейH(b,c,d,a, X[10], 23, 3200236656); // 0xbebfbc70 /* 40 */
	ВыполнитьОперациюСФункциейH(a,b,c,d, X[13],  4,  681279174); // 0x289b7ec6 /* 41 */
	ВыполнитьОперациюСФункциейH(d,a,b,c, X[ 0], 11, 3936430074); // 0xeaa127fa /* 42 */
	ВыполнитьОперациюСФункциейH(c,d,a,b, X[ 3], 16, 3572445317); // 0xd4ef3085 /* 43 */
	ВыполнитьОперациюСФункциейH(b,c,d,a, X[ 6], 23,   76029189); //  0x4881d05 /* 44 */
	ВыполнитьОперациюСФункциейH(a,b,c,d, X[ 9],  4, 3654602809); // 0xd9d4d039 /* 45 */
	ВыполнитьОперациюСФункциейH(d,a,b,c, X[12], 11, 3873151461); // 0xe6db99e5 /* 46 */
	ВыполнитьОперациюСФункциейH(c,d,a,b, X[15], 16,  530742520); // 0x1fa27cf8 /* 47 */
	ВыполнитьОперациюСФункциейH(b,c,d,a, X[ 2], 23, 3299628645); // 0xc4ac5665 /* 48 */
	
	// раунд 4
	ВыполнитьОперациюСФункциейI(a,b,c,d, X[ 0],  6, 4096336452); // 0xf4292244 /* 49 */
	ВыполнитьОперациюСФункциейI(d,a,b,c, X[ 7], 10, 1126891415); // 0x432aff97 /* 50 */
	ВыполнитьОперациюСФункциейI(c,d,a,b, X[14], 15, 2878612391); // 0xab9423a7 /* 51 */
	ВыполнитьОперациюСФункциейI(b,c,d,a, X[ 5], 21, 4237533241); // 0xfc93a039 /* 52 */
	ВыполнитьОперациюСФункциейI(a,b,c,d, X[12],  6, 1700485571); // 0x655b59c3 /* 53 */
	ВыполнитьОперациюСФункциейI(d,a,b,c, X[ 3], 10, 2399980690); // 0x8f0ccc92 /* 54 */
	ВыполнитьОперациюСФункциейI(c,d,a,b, X[10], 15, 4293915773); // 0xffeff47d /* 55 */
	ВыполнитьОперациюСФункциейI(b,c,d,a, X[ 1], 21, 2240044497); // 0x85845dd1 /* 56 */
	ВыполнитьОперациюСФункциейI(a,b,c,d, X[ 8],  6, 1873313359); // 0x6fa87e4f /* 57 */
	ВыполнитьОперациюСФункциейI(d,a,b,c, X[15], 10, 4264355552); // 0xfe2ce6e0 /* 58 */
	ВыполнитьОперациюСФункциейI(c,d,a,b, X[ 6], 15, 2734768916); // 0xa3014314 /* 59 */
	ВыполнитьОперациюСФункциейI(b,c,d,a, X[13], 21, 1309151649); // 0x4e0811a1 /* 60 */
	ВыполнитьОперациюСФункциейI(a,b,c,d, X[ 4],  6, 4149444226); // 0xf7537e82 /* 61 */
	ВыполнитьОперациюСФункциейI(d,a,b,c, X[11], 10, 3174756917); // 0xbd3af235 /* 62 */
	ВыполнитьОперациюСФункциейI(c,d,a,b, X[ 2], 15,  718787259); // 0x2ad7d2bb /* 63 */
	ВыполнитьОперациюСФункциейI(b,c,d,a, X[ 9], 21, 3951481745); // 0xeb86d391 /* 64 */
	
	a = БинарнаяСумма(a, aa);
	b = БинарнаяСумма(b, bb);
	c = БинарнаяСумма(c, cc);
	d = БинарнаяСумма(d, dd);
КонецПроцедуры

Процедура ВыполнитьОперациюСФункциейF(a, b, c, d, X, s, t)
	ВыполнитьОперацию(ПобитовоеИли(ПобитовоеИ(b, c), ПобитовоеИ(ПобитовоеНе(b), d)), a, b, X, s, t);
КонецПроцедуры

Процедура ВыполнитьОперациюСФункциейG(a, b, c, d, X, s, t)
	ВыполнитьОперацию(ПобитовоеИли(ПобитовоеИ(b, d), ПобитовоеИ(ПобитовоеНе(d), c)), a, b, X, s, t);
КонецПроцедуры

Процедура ВыполнитьОперациюСФункциейH(a, b, c, d, X, s, t)
	ВыполнитьОперацию(ПобитовоеИсключающееИли(ПобитовоеИсключающееИли(b, c), d), a, b, X, s, t);
КонецПроцедуры

Процедура ВыполнитьОперациюСФункциейI(a, b, c, d, X, s, t)
	ВыполнитьОперацию(ПобитовоеИсключающееИли(ПобитовоеИли(ПобитовоеНе(d), b), c), a, b, X, s, t);
КонецПроцедуры

Процедура ВыполнитьОперацию(q, a, b, X, s, t)
	a = БинарнаяСумма(ЦиклическийСдвигВлево(БинарнаяСумма(БинарнаяСумма(a, q), ЧислоВБинарныйМассив((X + t) % Pow(2,32))), s), b);
КонецПроцедуры

Функция ЧислоВБинарныйМассив(Знач Число, Знач ВсегоРазрядов = 32)
	Результат = Новый Массив;
	ТекущийРазряд = 0;
	Пока ТекущийРазряд < ВсегоРазрядов Цикл
		ТекущийРазряд = ТекущийРазряд + 1;
		Результат.Добавить(Булево(Число % 2));
		Число = Цел(Число / 2);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция БинарныйМассивВЧисло(Массив)
	Результат = 0;
	Для НомерРазряда = -(Массив.Количество()-1) По 0 Цикл
		Результат = Результат * 2 + Число(Массив[-НомерРазряда]);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ЧислоВШестнадцатеричномПредставлении(Знач Число, Знач КоличествоБайт = 4)
	Результат = "";
	СтрокаСимволов = "0123456789ABCDEF";
	Для НомерБайта = 1 По КоличествоБайт Цикл
		ПредставлениеБайта = "";
		Для Счетчик = 1 По 2 Цикл
			ПредставлениеБайта = Сред(СтрокаСимволов, Число % 16 + 1, 1) + ПредставлениеБайта;
			Число = Цел(Число / 16);
		КонецЦикла;
		
		// порядок байтов: начиная с младшего
		Результат = Результат + ПредставлениеБайта;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ПобитовоеИ(БинарныйМассив1, БинарныйМассив2)
	Результат = Новый Массив;
	Для Индекс = 0 По БинарныйМассив1.Количество()-1 Цикл
		Результат.Добавить(БинарныйМассив1[Индекс] И БинарныйМассив2[Индекс]);
	КонецЦикла;	
	Возврат Результат;
КонецФункции

Функция ПобитовоеИли(БинарныйМассив1, БинарныйМассив2)
	Результат = Новый Массив;
	Для Индекс = 0 По БинарныйМассив1.Количество()-1 Цикл
		Результат.Добавить(БинарныйМассив1[Индекс] Или БинарныйМассив2[Индекс]);
	КонецЦикла;	
	Возврат Результат;
КонецФункции

Функция ПобитовоеИсключающееИли(БинарныйМассив1, БинарныйМассив2)
	Результат = Новый Массив;
	Для Индекс = 0 По БинарныйМассив1.Количество()-1 Цикл
		Результат.Добавить(БинарныйМассив1[Индекс] <> БинарныйМассив2[Индекс]);
	КонецЦикла;	
	Возврат Результат;
КонецФункции

Функция ПобитовоеНе(БинарныйМассив)
	Результат = Новый Массив;
	Для Каждого Элемент Из БинарныйМассив Цикл
		Результат.Добавить(Не Элемент);
	КонецЦикла;	
	Возврат Результат;
КонецФункции

Функция ЦиклическийСдвигВлево(БинарныйМассив, КоличествоРазрядов)
	Результат = Новый Массив(БинарныйМассив.Количество());
	Для Разряд = 0 По БинарныйМассив.Количество()-1 Цикл
		Результат[(Разряд + КоличествоРазрядов) % БинарныйМассив.Количество()] = БинарныйМассив[Разряд];
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция БинарнаяСумма(БинарныйМассив1, БинарныйМассив2)
	Результат = Новый Массив;
	ДобавитьКРазряду = Ложь;
	Для Индекс = 0 По БинарныйМассив1.Количество()-1 Цикл
		Результат.Добавить(БинарныйМассив1[Индекс] <> БинарныйМассив2[Индекс] <> ДобавитьКРазряду);
		ДобавитьКРазряду = (0 + БинарныйМассив1[Индекс] + БинарныйМассив2[Индекс] + ДобавитьКРазряду) > 1;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция СкопироватьМассив(Массив)
	Результат = Новый Массив;
	Для Каждого Элемент Из Массив Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Преобразует исходную строку в число без вызова исключений.
//
// Параметры:
//   ИсходнаяСтрока - Строка - Строка, которую необходимо привести к числу.
//
// Возвращаемое значение:
//   Число - Полученное число.
//   Неопределено - Если строка не является числом.
//
Функция СтрокаВЧисло(Знач ИсходнаяСтрока) Экспорт
	ИсходнаяСтрока = СокрЛП(ИсходнаяСтрока);
	Результат = 0;
	ЗнаковПослеЗапятой = -1;
	ЗнакОтрицательный = Ложь;
	Длина = СтрДлина(ИсходнаяСтрока);
	Для НомерСимвола = 1 По Длина Цикл
		КодСимвола = КодСимвола(ИсходнаяСтрока, НомерСимвола);
		Если КодСимвола = 32 Или КодСимвола = 160 Тогда // Пробел или неразрывный пробел.
			// Пропуск (действие не требуется).
		ИначеЕсли КодСимвола = 45 Или КодСимвола = 40 Тогда // Минус или открывающая скобка.
			Если Результат <> 0 Тогда
				Возврат Неопределено;
			КонецЕсли;
			ЗнакОтрицательный = Истина;
		ИначеЕсли КодСимвола = 41 Тогда // Закрывающая скобка.
			Если Не ЗнакОтрицательный Или Результат = 0 Тогда // Не было открывающей скобки или нет числа.
				Возврат Неопределено;
			КонецЕсли;
			// Пропуск (действие не требуется).
		ИначеЕсли КодСимвола = 44 Или КодСимвола = 46 Тогда // Запятая или точка.
			Если ЗнаковПослеЗапятой <> -1 Тогда
				Возврат Неопределено; // Разделитель уже был, следовательно это не число.
			КонецЕсли;
			ЗнаковПослеЗапятой = 0; // Запуск отсчета знаков после запятой.
		ИначеЕсли КодСимвола > 47 И КодСимвола < 58 Тогда // Число.
			Если ЗнаковПослеЗапятой <> -1 Тогда
				ЗнаковПослеЗапятой = ЗнаковПослеЗапятой + 1;
			КонецЕсли;
			Число = КодСимвола - 48;
			Результат = Результат * 10 + Число;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗнаковПослеЗапятой > 0 Тогда
		Результат = Результат / Pow(10, ЗнаковПослеЗапятой);
	КонецЕсли;
	Если ЗнакОтрицательный Тогда
		Результат = -Результат;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Преобразует исходную строку в дату.
//
// Параметры:
//  ДатаСтрока - Строка - Строка, которую необходимо привести к дате.
// 
// Возвращаемое значение:
//  Дата - Полученная дата.
//
Функция СтрокаВДату(Знач ДатаСтрока) Экспорт
	
	ПозицияПробела = Найти(ДатаСтрока, " ");
	Если ПозицияПробела > 0 Тогда
		ДатаСтрока = Лев(ДатаСтрока, ПозицияПробела - 1);
	КонецЕсли;
	ДатаСтрока = СокрЛП(СтрЗаменить(ДатаСтрока, ".", ""));
	ДатаСтрока = Сред(ДатаСтрока, 5) + Сред(ДатаСтрока, 3, 2) + Лев(ДатаСтрока, 2);
	Если СтрДлина(ДатаСтрока) = 6 Тогда
		ДатаСтрока = "20" + ДатаСтрока;
	КонецЕсли;
	
	ОписаниеТипа = Новый ОписаниеТипов("Дата");
	Результат    = ОписаниеТипа.ПривестиЗначение(ДатаСтрока);
	
	Возврат Результат;
	
КонецФункции 

// Сравнить две строки версий.
//
// Параметры
//  СтрокаВерсии1  – Строка – номер версии в формате РР.{П|ПП}.ЗЗ.СС
//  СтрокаВерсии2  – Строка – второй сравниваемый номер версии
//
// Возвращаемое значение:
//   Число   – больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	Возврат ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СтрокаВерсии1, СтрокаВерсии2);
КонецФункции

// Получает номер версии конфигурации без номера сборки
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС – номер сборки, который будет удален
// 
//  Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = РазложитьСтрокуВМассивПодстрок(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции

// Конец ВычислитьХешСтрокиПоАлгоритмуMD5
